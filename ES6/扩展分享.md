## 1、数值扩展
### 1.1、Number.EPSILON：
Number.EPSILON 是 JavaScript 表示的最小精度；
EPSILON 属性的值接近于 2.2204460492503130808472633361816E-16；

```javascript
			// JS 小数计算
			console.log(0.1 + 0.2 === 0.3)

			// 数值拓展
			function equal(a, b) {
				if (Math.abs(a - b) < Number.EPSILON) {
					return true;
				} else {
					return false;
				}
			}
			console.log(equal(0.1 + 0.2, 0.3))
```

### 1.2、二进制和八进制：
ES6 提供了二进制和八进制数值的新的写法，分别用前缀 0b 和 0o 表示；

```javascript
			// 二进制 八进制 十六进制
			let b = 0b111;
			let o = 0o111;
			let x = 0xff;
			console.log(b)
			console.log(o)
			console.log(x)
```

### 1.3、Number.isFinite() 与 Number.isNaN() ：
Number.isFinite() 用来检查一个数值是否为有限的；
Number.isNaN() 用来检查一个值是否为 NaN；

```javascript
			// 是否为有限数
			console.log(Number.isFinite(100))
			console.log(Number.isFinite(100 / 0))

			// isNaN
			console.log(Number.isNaN(123))
```

### 1.4、Number.parseInt() 与 Number.parseFloat()：
ES6 将全局方法 parseInt 和 parseFloat，移植到 Number 对象上面，使用不变；

```javascript
			// 字符串转整数
			console.log(Number.parseInt("123456asdf"))
			console.log(Number.parseFloat("123.456asdf"))
```

### 1.5、Math.trunc：
用于去除一个数的小数部分，返回整数部分；

```javascript
			// 将数字的小数去掉
			console.log(Math.trunc(123.587))
```

### 1.6、Number.isInteger：
Number.isInteger() 用来判断一个数值是否为整数；

```javascript
			// 判断是否为整数
			console.log(Number.isInteger(2))
			console.log(Number.isInteger(2.32))
```
## 2、函数扩展
### 2.1、rest 参数
ES6 引入 rest 参数，用于获取函数的实参，用来代替 arguments

代码示例：

```javascript
			// ES5
			function data(){
				console.log(arguments)
			}
			data('黄','月','月');
			// ES6 rest参数
			// rest 参数必须放在最后
			function data1(...args){
				console.log(args)
			}
			data1('黄','月','月');
```
### 2.2、箭头函数
ES6 允许使用「箭头」（=>）定义函数。

箭头函数的注意点:
1. 如果形参只有一个，则小括号可以省略
2. 函数体如果只有一条语句，则花括号可以省略，函数的返回值为该条语句的执行结果
3. 箭头函数 this 指向声明时所在作用域下 this 的值
4. 箭头函数不能作为构造函数实例化
5. 不能使用 arguments

代码示例：

```javascript
			let f = function() {}
			let t = (a, b) => {
				return a + b
			}
			console.log(t(1, 2))
			// 箭头函数的特点
			// 1 this是静态的，this始终指向函数声明时所在作用域下的this
			function getName() {
				console.log(this.name)
			}
			let getName1 = () => {
				console.log(this.name)
			}
			// 改变window下的这个name的值
			window.name = '月月鸟'
			getName()
			getName1()

			const obj1 = {
				name: '黄月月'
			}
			// 使用call函数改变当前this的值
			getName.call(obj1)
			getName1.call(obj1)

			// 不能使用箭头函数保存agruments实参
			let fn = () => {
				console.log(arguments);
			}
			// fn()
			// 箭头函数的省略
			let fn1 = (n) => {
				return n * n
			}
			// 当形参只有一个点时候可以省略括号
			let fn2 = n => {
				return n * n
			}
			// 只有一条语句可省略大括号和return
			let fn3 = n => n * n
			console.log(fn1(3))
			console.log(fn2(3))
			console.log(fn3(3))
```

## 3、数组扩展
### 3.1、spread 扩展运算符
扩展运算符（spread）也是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列，对数组进行解包。

代码示例：

```javascript
			//  ... 扩展运算符可以将数组转换为逗号分隔的参数序列
			const IG = ['the shy','ning','rookie','jackerlove','baolan']
			
			function LPL(){
				console.log(arguments)
			}
			LPL(IG)
			LPL(...IG)
			
			// 数组合并
			const a = ['1','2','3']
			const b = ['4','5','6']
			// 对于ES5
			console.log(a.concat(b))
			// 对于ES6 扩展运算符来说直接在中间加上一个逗号即可
			console.log([...a,...b]);
			
			// 数组克隆
			const SZH = ['E','G','M']
			const SYC = [...SZH]
			console.log(SYC)
			
			// 伪数组转真数组
			const divs = document.querySelectorAll("div")
			const divArr = [...divs]
			console.log(divArr)
```
### 3.2、flat 与 flatMap
flat 方法会按照一个指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回

flatMap方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与map连着深度值为1的flat几乎相同，但flatMap通常在合并成一种方法的效率稍微高些。

代码示例：
```javascript
			// flat 多维数组转低维数组
			let arr = [1, 2, 3, [4, 5, [1, 55, [4]]]]
			// 参数 表示 降几个维度
			console.log(arr.flat(2))

			let arr1 = [4, 5, 2]
			const res = arr1.flatMap((item) => [item * 58])
			console.log(res)
```
## 4、对象扩展
### 4.1、对象简化
ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这
样的书写更加简洁。

代码示例：

```javascript
			let name = "name";
			let change = function(){
				console.log("change")
			}
			const obj ={
				name,
				change,
				noChange:function(){
					console.log("no change")
				}
			}
			console.log(obj)
```
### 4.2、ES6 新增了一些 Object 对象的方法：
1. Object.is 比较两个值是否严格相等，与『===』行为基本一致（+0 与 NaN）；
2. Object.assign 对象的合并，将源对象的所有可枚举属性，复制到目标对象；
3. proto、setPrototypeOf、 setPrototypeOf 可以直接设置对象的原型；

代码示例：

```javascript
			//Object.is  判断两个值是否相等
			console.log(Object.is(120, 1))
			console.log(Object.is(NaN, NaN))
			console.log(NaN == NaN)
			//Object.assign 对象合并
			const a = {
				name: 'yue',
				age: '18',
				size: 10
			}
			const b = {
				name: 'huang',
				age: '22',
				color: 'blue'
			}
			// 出现重名进行覆盖
			console.log(Object.assign(a, b))

			// 设置原型对象
			const school = {
				name: '民院'
			}
			const city = {
				xiaoqu: ['长沙', '广州']
			}
			Object.setPrototypeOf(school, city)
			console.log(Object.getPrototypeOf(school))
			console.log(school)
```
### 4.3、ES8新增对象扩展
#### 4.3.1、Object.values 和 Object.entries
1. Object.values()方法返回一个给定对象的所有可枚举属性值的数组
2. Object.entries()方法返回一个给定对象自身可遍历属性 [key,value] 的数组

#### 4.2.2、Object.getOwnPropertyDescriptors
该方法返回指定对象所有自身属性的描述对象

代码示例：

```javascript
			const school = {
				name: '民院',
				cities: ['长沙',
					'广州',
					'深圳',
				],
			}

			// 获取所有键与值
			console.log(Object.keys(school))
			console.log(Object.values(school))
			console.log(Object.entries(school))

			const map = new Map(Object.entries(school))
			console.log(map.get('name'))
			
			console.log(Object.getOwnPropertyDescriptors(school))
```
